<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-11-25T01:56:22+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">NUS AI Blog</title><subtitle>Document my learning notes.</subtitle><author><name>NUS AI Blog</name></author><entry><title type="html">How to Train Really Large Models on Many GPUs?</title><link href="http://localhost:4000/2021/09/24/train-large-neural-networks.html" rel="alternate" type="text/html" title="How to Train Really Large Models on Many GPUs?" /><published>2021-09-24T20:00:00+08:00</published><updated>2021-09-24T20:00:00+08:00</updated><id>http://localhost:4000/2021/09/24/train-large-neural-networks</id><content type="html" xml:base="http://localhost:4000/2021/09/24/train-large-neural-networks.html">&lt;blockquote&gt;
  &lt;p&gt;[PLACE-HOLDER POST, COPYRIGHT LILIAN WENG] How to train large and deep neural networks is challenging, as it demands a large amount of GPU memory and a long horizon of training time. This post reviews several popular training parallelism paradigms, as well as a variety of model architecture and memory saving designs to make it possible to train very large neural networks across a large number of GPUs.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;!--more--&gt;

&lt;p&gt;[PLACE-HOLDER POST, COPYRIGHT LILIAN WENG] In recent years, we are seeing better results on many NLP benchmark tasks with larger pre-trained &lt;a href=&quot;/2021/09/24/train-large-neural-networks.html&quot;&gt;language models&lt;/a&gt;. How to train large and deep neural networks is challenging, as it demands a large amount of GPU memory and a long horizon of training time.&lt;/p&gt;

&lt;p&gt;However an individual GPU worker has limited memory and the sizes of many large models have grown beyond a single GPU. There are several parallelism paradigms to enable model training across multiple GPUs, as well as a variety of model architecture and memory saving designs to help make it possible to train &lt;em&gt;very large&lt;/em&gt; neural networks.&lt;/p&gt;

&lt;ul class=&quot;table-of-content&quot; id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#training-parallelism&quot; id=&quot;markdown-toc-training-parallelism&quot;&gt;Training Parallelism&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#data-parallelism&quot; id=&quot;markdown-toc-data-parallelism&quot;&gt;Data Parallelism&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#model-parallelism&quot; id=&quot;markdown-toc-model-parallelism&quot;&gt;Model Parallelism&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pipeline-parallelism&quot; id=&quot;markdown-toc-pipeline-parallelism&quot;&gt;Pipeline Parallelism&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#tensor-parallelism&quot; id=&quot;markdown-toc-tensor-parallelism&quot;&gt;Tensor Parallelism&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#mixture-of-experts-moe&quot; id=&quot;markdown-toc-mixture-of-experts-moe&quot;&gt;Mixture-of-Experts (MoE)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#other-memory-saving-designs&quot; id=&quot;markdown-toc-other-memory-saving-designs&quot;&gt;Other Memory Saving Designs&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#cpu-offloading&quot; id=&quot;markdown-toc-cpu-offloading&quot;&gt;CPU Offloading&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#activation-recomputation&quot; id=&quot;markdown-toc-activation-recomputation&quot;&gt;Activation Recomputation&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mixed-precision-training&quot; id=&quot;markdown-toc-mixed-precision-training&quot;&gt;Mixed Precision Training&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#compression&quot; id=&quot;markdown-toc-compression&quot;&gt;Compression&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#memory-efficient-optimizer&quot; id=&quot;markdown-toc-memory-efficient-optimizer&quot;&gt;Memory Efficient Optimizer&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;training-parallelism&quot;&gt;Training Parallelism&lt;/h2&gt;

&lt;p&gt;The main bottleneck for training very large neural network models is the intense demand for a large amount of GPU memory, way above what can be hosted on an individual GPU machine. Besides the model weights (e.g. tens of billions of floating point numbers), it is usually even more expensive to store intermediate computation outputs such as gradients and optimizer states (e.g. momentums &amp;amp; variations in Adam). Additionally training a large model often pairs with a large training corpus and thus a single process may just take forever.&lt;/p&gt;

&lt;p&gt;As a result, parallelism is necessary. Parallelism can happen at different dimensions, including data, model architecture, and tensor operation.&lt;/p&gt;

&lt;h3 id=&quot;data-parallelism&quot;&gt;Data Parallelism&lt;/h3&gt;

&lt;p&gt;The most naive way for &lt;strong&gt;Data parallelism (DP)&lt;/strong&gt;  is to copy the same model weights into multiple workers and assign a fraction of data to each worker to be processed at the same time.&lt;/p&gt;

&lt;p&gt;Naive DP cannot work well if the model size is larger than a single GPU node’s memory. Methods like &lt;em&gt;GeePS&lt;/em&gt; (&lt;a href=&quot;https://www.pdl.cmu.edu/PDL-FTP/CloudComputing/GeePS-cui-eurosys16.pdf&quot;&gt;Cui et al. 2016&lt;/a&gt;) offload temporarily unused parameters back to CPU to work with limited GPU memory when the model is too big to fit into one machine. The data swapping transfer should happen at the backend and not interfere with training computation.&lt;/p&gt;

&lt;p&gt;At the end of each minibatch, workers need to synchronize gradients or weights to avoid staleness. There are two main synchronization approaches and both have clear pros &amp;amp; cons.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;em&gt;Bulk synchronous parallels (BSP)&lt;/em&gt;: Workers sync data at the end of every minibatch. It prevents model weights staleness and good learning efficiency but each machine has to halt and wait for others to send gradients.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Asynchronous  parallel (ASP)&lt;/em&gt;: Every GPU worker processes the data asynchronously, no waiting or stalling. However, it can easily lead to stale weights being used and thus lower the statistical learning efficiency. Even though it increases the computation time, it may not speed up training time to convergence.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Somewhere in the middle is to synchronize gradients globally once every \(x\) iterations (\(x &amp;gt; 1\)). This feature is called “gradient accumulation” in Distribution Data Parallel (&lt;a href=&quot;https://pytorch.org/tutorials/intermediate/ddp_tutorial.html&quot;&gt;DDP&lt;/a&gt;) since Pytorch v1.5 (&lt;a href=&quot;https://arxiv.org/abs/2006.15704&quot;&gt;Li et al. 2021&lt;/a&gt;). Bucketing gradients avoid immediate &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AllReduce&lt;/code&gt; operations but instead buckets multiple gradients into one &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AllReduce&lt;/code&gt; to improve throughput. Computation and communication scheduling optimization can be made based on the computation graph.&lt;/p&gt;

&lt;p style=&quot;width: 68%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/pytorch-ddp.png&quot; alt=&quot;Pytorch DDP&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 1. Pseudo code for Pytorch DDP. (Image source: &lt;a href=&quot;https://arxiv.org/abs/2006.15704&quot;&gt;Li et al. 2021&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;model-parallelism&quot;&gt;Model Parallelism&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Model parallelism (MP)&lt;/strong&gt; aims to solve the case when the model weights cannot fit into a single node. The computation and model parameters are partitioned across multiple machines. Different from data parallelism where each worker hosts a full copy of the entire model, MP only allocates a fraction of model parameters on one worker and thus both the memory usage and the computation are reduced.&lt;/p&gt;

&lt;p&gt;Since deep neural networks usually contain a stack of vertical layers, it feels straightforward to split a large model by layer, where a small consecutive set of layers are grouped into one partition on one worker. However, a naive implementation for running every data batch through multiple such workers with sequential dependency leads to big bubbles of waiting time and severe under-utilization of computation resources.&lt;/p&gt;

&lt;p style=&quot;width: 90%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/naive-data-parallelism.png&quot; alt=&quot;Naive DP&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 2. A naive model parallelism setup where the model is vertically split into 4 partitions. Data is processed by one worker at a time due to sequential dependency, leading to large “bubbles” of idle time. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1811.06965&quot;&gt;Huang et al. 2019&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;pipeline-parallelism&quot;&gt;Pipeline Parallelism&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Pipeline parallelism (PP)&lt;/strong&gt; combines model parallelism with data parallelism to reduce inefficient time “bubbles’’. The main idea is to split one minibatch into multiple microbatches and enable each stage worker to process one microbatch simultaneously. Note that every microbatch needs two passes, one forward and one backward. Inter-worker communication only transfers activations (forward) and gradients (backward). How these passes are scheduled and how the gradients are aggregated vary in different approaches. The number of partitions (workers) is also known as &lt;em&gt;pipeline depth&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In &lt;em&gt;GPipe&lt;/em&gt; (&lt;a href=&quot;https://arxiv.org/abs/1811.06965&quot;&gt;Huang et al. 2019&lt;/a&gt;) gradients from multiple microbatches are aggregated and applied synchronously at the end. The synchronous gradient descent guarantees learning consistency and efficiency irrespective of the number of workers. As shown in Fig. 3, bubbles still exist but are much smaller than what’s in Fig. 2. Given \(m\) evenly split microbatches and \(d\) partitions, assuming both forward and backward per microbatch take one unit of time, the fraction of bubble is:&lt;/p&gt;

\[1 - \frac{2md}{(2m + 2(d-1))d} = \frac{d-1}{m+d-1}\]

&lt;p&gt;The GPipe paper observed that the bubble overhead is almost negligible if the number of microbatches is more than 4x the number of partitions \(m &amp;gt; 4d\) (when &lt;a href=&quot;#activation-recomputation&quot;&gt;activation recomputation&lt;/a&gt; is applied).&lt;/p&gt;

&lt;p style=&quot;width: 80%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/gpipe.png&quot; alt=&quot;GPipe&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 3. Illustration of pipeline parallelism in GPipe with 4 microbatches and 4 partitions. GPipe aggregates and updates gradients across devices synchronously at the end of every batch. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1811.06965&quot;&gt;Huang et al. 2019&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;GPipe achieves almost linear speedup in throughput with the number of devices, although it is not always guaranteed if the model parameters are not evenly distributed across workers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PipeDream&lt;/em&gt; (&lt;a href=&quot;https://cs.stanford.edu/~matei/papers/2019/sosp_pipedream.pdf&quot;&gt;Narayanan et al. 2019&lt;/a&gt;) schedules each worker to alternatively process the forward and backward passes (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1F1B&lt;/code&gt;). 
PipeDream names each model partition “stage” and each stage worker can have multiple replicas to run data parallelism. In this process, PipeDream uses a deterministic round-robin load balancing strategy to assign work among multiple replicas of stages to ensure that the forward and backward passes for the same minibatch happen on the same replica.&lt;/p&gt;

&lt;p style=&quot;width: 75%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/pipedream.png&quot; alt=&quot;PipeDream&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 4. Illustration of &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1F1B&lt;/code&gt; microbatch scheduling in PipeDream. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1806.03377&quot;&gt;Harlap et al. 2018&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Since PipeDream does not have an end-of-batch global gradient sync across all the workers, an native implementation of 1F1B can easily lead to the forward and backward passes of one microbatch using different versions of model weights, thus lowering the learning efficiency. PipeDream proposed a few designs to tackle this issue:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Weight stashing&lt;/em&gt;: Each worker keeps track of several model versions and makes sure that the same version of weights are used in the forward and backward passes given one data batch.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Vertical sync&lt;/em&gt; (Optional): The version of model weights flows between stage workers together with activations and gradients. Then the computation adopts the corresponding stashed version propagated from the previous worker. This process keeps version consistency across workers. Note that it is asynchronous, different from GPipe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the beginning of a training run, PipeDream first profiles the computation memory cost and time of each layer in the model and then optimizes a solution for partitioning layers into stages, which is a dynamic programming problem.&lt;/p&gt;

&lt;p style=&quot;width: 70%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/pipedream-results.png&quot; alt=&quot;PipeDream experiments&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 5. Results for VGG16 on ILSVRC12. (Top) Accuracy vs time. The integer marks the number of stage workers. ASP =  Asynchronous  parallel &amp;amp; BSP = Bulk synchronous parallels. (Bottom) Training time speedup for different parallelism configurations. Straight pipeline refers to pipeline parallelism without data parallelism. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1806.03377&quot;&gt;Harlap et al. 2018&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Two variations of PipeDream were later proposed to reduce the memory footprint by stashed model versions (&lt;a href=&quot;https://arxiv.org/abs/2006.09503&quot;&gt;Narayanan et al. 2021&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PipeDream-flush&lt;/em&gt; adds a globally synchronized pipeline flush periodically, just like GPipe. In this way, it greatly reduces the memory footprint (i.e. only maintain a single version of model weights) by sacrificing a little throughput.&lt;/p&gt;

&lt;p style=&quot;width: 70%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/pipedream-flush.png&quot; alt=&quot;PipeDream-flush&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 6. Illustration of pipeline scheduling in PipeDream-flush. (Image source: (&lt;a href=&quot;https://arxiv.org/abs/2006.09503&quot;&gt;Narayanan et al. 2021&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;PipeDream-2BW&lt;/em&gt; maintains only two versions of model weights, where “2BW” is short for “double-buffered weights”. It generates a new model version every \(k\) microbatches and \(k\) should be larger than the pipeline depth \(d\), \(k &amp;gt; d\). A newly updated model version cannot fully replace the old version immediately since some leftover backward passes still depend on the old version. In total only two versions need to be saved so the memory cost is much reduced.&lt;/p&gt;

&lt;p style=&quot;width: 95%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/pipedream-2bw.png&quot; alt=&quot;PipeDream-2BW&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 7. Illustration of pipeline scheduling in PipeDream-2BW. (Image source: (&lt;a href=&quot;https://arxiv.org/abs/2006.09503&quot;&gt;Narayanan et al. 2021&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;tensor-parallelism&quot;&gt;Tensor Parallelism&lt;/h3&gt;

&lt;p&gt;Both model and pipeline parallelisms split a model vertically. OTOH we can horizontally partition the computation for one tensor operation across multiple devices, named &lt;strong&gt;Tensor parallelism (TP)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Let’s take the transformer as an example given its popularity. The transformer model mainly consists of layers of MLP and self-attention blocks. &lt;em&gt;Megatron-LM&lt;/em&gt; (&lt;a href=&quot;https://arxiv.org/abs/1909.08053&quot;&gt;Shoeybi et al. 2020&lt;/a&gt;) adopts a simple way to parallelize intra-layer computation for MLP and self-attention.&lt;/p&gt;

&lt;p&gt;A MLP layer in a transformer contains a GEMM (General matrix multiply) followed by an non-linear GeLU transfer. Let’s split weight matrix \(A\) by column:&lt;/p&gt;

\[\begin{aligned}
\text{Split }A &amp;amp;= [A_1, A_2] \\
Y &amp;amp;=\text{GeLU}(XA) \\
[Y_1, Y_2] &amp;amp;= [\text{GeLU}(XA_1), \text{GeLU}(XA_2)]
\end{aligned}\]

&lt;p&gt;The attention block runs GEMM with query (\(Q\)), key (\(K\)), and value weights (\(V\)) according to the above partitioning in parallel and then combines them with another GEMM to produce the attention head results.&lt;/p&gt;

\[\text{Attention}(X, Q, K, V) = \text{softmax}(\frac{(XQ) (XK)^\top}{\sqrt{d_k}}) XV\]

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/Megatron-LM.png&quot; alt=&quot;Megatron LM&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 8. Illustration of tensor parallelism for key transformer components proposed in Megatron-LM. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1909.08053&quot;&gt;Shoeybi et al. 2020&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/2104.04473&quot;&gt;Narayanan et al. (2021)&lt;/a&gt; combined pipeline, tensor and data parallelism with a new pipeline scheduling strategy and named their approach &lt;em&gt;PTD-P&lt;/em&gt;. Instead of only positioning a continuous set of layers (“model chunk”) on a device, each worker can be assigned with multiple chunks of smaller continuous subsets of layers (e.g. device 1 has layers 1, 2, 9, 10; device 2 has layers 3, 4, 11, 12; each has two model chunks). The number of microbatches in one batch should be exactly divided by the number of workers (\(m % d = 0\)). If there are \(v\) model chunks per worker, the pipeline bubble time can be reduced by a multiplier of \(v\) compared to a GPipe scheduling.&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/PTD-P-interleaved.png&quot; alt=&quot;PTD-P&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 9. (Top) Default &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1F1B&lt;/code&gt; pipeline schedule as in PipeDream-flush. (Bottom) Interleaved 1F1B pipeline schedule. First model chunks are in dark colors and second chunks are in light colors. (Image source: &lt;a href=&quot;https://arxiv.org/abs/2104.04473&quot;&gt;Narayanan et al. 202)&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;mixture-of-experts-moe&quot;&gt;Mixture-of-Experts (MoE)&lt;/h2&gt;

&lt;p&gt;The &lt;strong&gt;Mixture-of-Experts (MoE)&lt;/strong&gt; approach attracts a lot of attention recently as researchers (mainly from Google) try to push the limit of model size. The core of the idea is &lt;a href=&quot;https://en.wikipedia.org/wiki/Ensemble_learning&quot;&gt;ensembling learning&lt;/a&gt;: &lt;em&gt;Combination of multiple weak learners gives you a strong learner!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Within one deep neural network, ensembling can be implemented with a gating mechanism connecting multiple experts (&lt;a href=&quot;https://arxiv.org/abs/1701.06538&quot;&gt;Shazeer et al., 2017&lt;/a&gt;). The gating mechanism controls which subset of the network (e.g. which experts) should be activated to produce outputs. The paper named it “sparsely gated mixture-of-experts” (MoE) layer.&lt;/p&gt;

&lt;p&gt;Precisely one MoE layer contains&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;\(n\) feed-forward networks as experts \(\{E_i\}^n_{i=1}\)&lt;/li&gt;
  &lt;li&gt;A trainable gating network \(G\) to learn a probability distribution over \(n\) experts so as to route the traffic to a few selected experts.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Depending on the gating outputs, not every expert has to be evaluated. When the number of experts is too large, we can consider using a two-level hierarchical MoE.&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/moe.png&quot; alt=&quot;MoE&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 10. Illustration of a mixture-of-experts (MoE) layer. Only 2 out of \(n\) experts are selected and activated by the gating network. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1701.06538&quot;&gt;Shazeer et al., 2017&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A simple choice of \(G\) is to multiply the input with a trainable weight matrix \(G_g\) and then do softmax: \(G_\sigma (x) = \text{softmax}(x W_g)\). However, this produces a dense control vector for gating and does not help save computation resources because we don’t need to evaluate an expert only when \(G^{(i)}(x)=0\). Thus the MoE layer only keeps the top \(k\) values. It also adds tunable Gaussian noise into \(G\) to improve load balancing. This mechanism is called &lt;em&gt;noisy top-k gating&lt;/em&gt;.&lt;/p&gt;

\[\begin{aligned} 
G(x) &amp;amp;= \text{softmax}( \text{topk}(H(x), k)) \\
H^{(i)}(x) &amp;amp;= (xW_g)^{(i)} + \epsilon \cdot \text{softplus}((xW_\text{noise})^{(i)} ); \quad \epsilon \sim \mathcal{N}(0, \mathbf{1}) \\
\text{topk}^{(i)}(v, k) &amp;amp;= \begin{cases} v^{(i)} &amp;amp; \text{if }v^{(i)}\text{ is in the top }k\text{ elements of }v \\ -\infty &amp;amp; \text{otherwise} 
\end{cases} 
\end{aligned}\]

&lt;p&gt;where the superscript \(v^{(i)}\) denotes the i-th dimension of the vector \(v\). The function \(\text{topk}(., k)\) selected the top \(k\) dimensions with highest values by setting other dimensions to \(-\infty\).&lt;/p&gt;

&lt;p&gt;To avoid the self-reinforcing effect that the gating network may favor a few strong experts all the time, &lt;a href=&quot;https://arxiv.org/abs/1701.06538&quot;&gt;Shazeer et al. (2017)&lt;/a&gt; proposed a soft constraint via an additional importance loss to encourage all the experts to have the same weights. It is equivalent to the square of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Coefficient_of_variation&quot;&gt;coefficient of variation&lt;/a&gt; of batchwise average value per expert.&lt;/p&gt;

\[L_\text{aux} = w_\text{aux} \cdot \text{CV}(\sum_{x \in X} G(x))^2\]

&lt;p&gt;where \(\text{CV}\) is the coefficient of variation and the loss weight \(w_\text{aux}\) is a hyperparameter to tune.&lt;/p&gt;

&lt;p&gt;Because every expert network only gets a fraction of training samples (“The shrinking batch problem”), we should try to use a batch size as large as possible in MoE. However, it is restricted by GPU memory. Data parallelism and model parallelism can be applied to improve the throughput.&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/moe-experiments.png&quot; alt=&quot;MoE experiments&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 11. Test perplexity on 1-Billion-Word language modeling benchmark. (Left) The model capacity increases from left to right, containing 4, 32, 256, 256, 1024 and 4096 experts. (Right) Performance of the 4 billion parameters MoE model, the largest one in the left figure, under different computation budgets. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1701.06538&quot;&gt;Shazeer et al., 2017&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GShard&lt;/strong&gt; (&lt;a href=&quot;https://arxiv.org/abs/2006.16668&quot;&gt;Lepikhin et al., 2020&lt;/a&gt;) scales the MoE transformer model up to 600 billion parameters with sharding. The MoE transformer replaces every other feed forward layer with a MoE layer. The &lt;em&gt;sharded MoE transformer&lt;/em&gt; only has the MoE layers sharded across multiple machines, while other layers are simply duplicated.&lt;/p&gt;

&lt;p&gt;There are several improved designs for the gating function \(G\) in GShard:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Expert capacity&lt;/em&gt;: The amount of tokens going through one expert should not go above a threshold, named “expert capacity”. If a token is routed to experts that have reached their capacity, the token would be marked “overflowed” and the gating output is changed to a zero vector.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Local group dispatching&lt;/em&gt;: Tokens are evenly partitioned into multiple local groups and the expert capacity is enforced on the group level.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Auxiliary loss&lt;/em&gt;: The motivation is similar to the original MoE aux loss. They add an auxiliary loss to minimize the mean square of the fraction of data routed to each expert.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Random routing&lt;/em&gt;: The 2nd-best expert is selected with a probability proportional to its weight; otherwise, GShard follows a random routing, so as to add some randomness.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/gshard-algo.png&quot; alt=&quot;GShard algorithm&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 12. Pseudo code of the group-level top-2 gating mechanism with auxiliary loss in GShard. (Image source: &lt;a href=&quot;https://arxiv.org/abs/2006.16668&quot;&gt;Lepikhin et al., 2020&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Switch Transformer&lt;/strong&gt; (&lt;a href=&quot;https://arxiv.org/abs/2101.03961&quot;&gt;Fedus et al. 2021&lt;/a&gt;) scales the model size up to trillions of parameters (!!) by replacing the dense feed forward layer with a &lt;em&gt;sparse switch FFN layer&lt;/em&gt; in which each input is only routed to &lt;em&gt;one&lt;/em&gt; expert network. The auxiliary loss for load balancing is \(\text{loss}_\text{aux} = w_\text{aux} \sum_{i=1}^n f_i p_i\) given \(n\) experts, where \(f_i\) is the fraction of tokens routed to the \(i\)-th expert and \(p_i\) is the routing probability for expert \(i\) predicted by the gating network.&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/switch-transformer.png&quot; alt=&quot;Switch transformer&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 13. Switch transformer. The sparse switch FFN layer is in the blue boxes. (Image source: &lt;a href=&quot;https://arxiv.org/abs/2101.03961&quot;&gt;Fedus et al. 2021&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;To improve training stability, switch transformer incorporates the following designs:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Selective precision&lt;/em&gt;. They showed that selectively casting only a local part of the model to FP32 precision improves stability, while avoiding the expensive communication cost of FP32 tensors. The FP32 precision is only used within the body of the router function and the results are recast to FP16.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Smaller initialization&lt;/em&gt;. The initialization of weight matrices is sampled from a truncated normal distribution with mean \(\mu=0\) and stdev \(\sigma = \sqrt{s/n}\). They also recommended reducing the transformer initialization scale parameter \(s=1\) to \(s=0.1\).&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Use higher expert dropout&lt;/em&gt;. Fine-tuning often works with a small dataset. To avoid overfitting, the dropout rate within each expert is increased by a significant amount. Interestingly they found that increasing dropout across all layers lead to poor performance. In the paper, they used a dropout rate 0.1 at non-expert layers but 0.4 within expert FF layers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The switch transformer paper summarized different data and model parallelism strategies for training large models with a nice illustration:&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/switch-transformer-parallelism.png&quot; alt=&quot;Parallelism strategies&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 14. An illustration of various parallelism strategies on how (Top) model weights and (Bottom) data are split over multiple GPU cores. In the top row, each color denotes a unique weight matrix. In the bottom row, different colors indicate different sets of tokens.  (Image source: &lt;a href=&quot;https://arxiv.org/abs/2101.03961&quot;&gt;Fedus et al. 2021&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;other-memory-saving-designs&quot;&gt;Other Memory Saving Designs&lt;/h2&gt;

&lt;h3 id=&quot;cpu-offloading&quot;&gt;CPU Offloading&lt;/h3&gt;

&lt;p&gt;When the GPU memory is full, one option is to offload temporarily unused data to CPU and read them back when needed later (&lt;a href=&quot;https://arxiv.org/abs/1602.08124&quot;&gt;Rhu et al. 2016&lt;/a&gt;). The idea of &lt;strong&gt;CPU offloading&lt;/strong&gt; is straightforward but is less popular in recent years due to the slowdown it brings into the training time.&lt;/p&gt;

&lt;h3 id=&quot;activation-recomputation&quot;&gt;Activation Recomputation&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Activation recomputation&lt;/strong&gt; (also known as “activation checkpointing” or “gradient checkpointing”; [Chen et al. 2016 (https://arvix.org/abs/1604.06174)) is a smart yet simple idea to reduce memory footprint at the cost of computation time. It reduces the memory cost of training a \(\ell\) layer deep neural net to \(O(\sqrt{\ell})\), which only additionally consumes an extra forward pass computation per batch.&lt;/p&gt;

&lt;p&gt;Let’s say, we evenly divide an \(\ell\)-layer network into \(d\) partitions. Only activations at partition boundaries are saved and communicated between workers. Intermediate activations at intra-partition layers are still needed for computing gradients so they are recomputed during backward passes. With activation recomputation, the memory cost for training \(M(\ell)\) is:&lt;/p&gt;

\[M(\ell) 
=\max_{i=1,\dots,k} \underbrace{\text{cost-of-one-partition}(i)}_\text{cost of back-propagation on the i-th partition} + \underbrace{O(d)}_\text{store intermediate outputs} 
= O(\frac{\ell}{d}) + O(d)\]

&lt;p&gt;The minimum cost is \(O(\sqrt{\ell})\) at \(d=\sqrt{\ell}\).&lt;/p&gt;

&lt;p&gt;Activation recompuation trick can give sublinear memory cost with respect to the model size.&lt;/p&gt;

&lt;p style=&quot;width: 100%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/activation-checkpointing.png&quot; alt=&quot;Activation checkpointing experiments&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 15. The memory cost of different memory saving algorithms. &lt;u&gt;Sharing&lt;/u&gt;: Memory used by intermediate results is recycled when no longer needed. &lt;u&gt;Inplace&lt;/u&gt;: Save the output directly into memory of an input value. (Image source: &lt;a href=&quot;https://arvix.org/abs/1604.06174&quot;&gt;Chen et al. 2016&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;mixed-precision-training&quot;&gt;Mixed Precision Training&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;https://arxiv.org/abs/1710.03740&quot;&gt;Narang &amp;amp; Micikevicius et al. (2018)&lt;/a&gt; introduced a method to train models using half-precision floating point (FP16) numbers without losing model accuracy.&lt;/p&gt;

&lt;p style=&quot;width: 80%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/mixed-precision-training.png&quot; alt=&quot;Mixed-precision training&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 16. The procedure of mixed precision training at one layer. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1710.03740&quot;&gt;Narang &amp;amp; Micikevicius, et al. 2018&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Three techniques to avoid losing critical information at half-precision:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;Full-precision master copy of weights&lt;/em&gt;. Maintain a full precision (FP32) copy of model weights that accumulates gradients. The numbers are rounded up to half-precision for forward &amp;amp; backward passes. The motivation is that each gradient update (i.e. gradient times the learning rate) might be too small to be fully contained within the FP16 range (i.e. \(2^{-24}\) becomes zero in FP16).&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Loss scaling&lt;/em&gt;. Scale up the loss to better handle gradients with small magnitudes (See Fig. 16). Scaling up the gradients helps shift them to occupy a larger section towards the right section (containing larger values) of the representable range, preserving values that are otherwise lost.&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Arithmetic precision&lt;/em&gt;. For common network arithmetic (e.g. vector dot-product, reduction by summing up vector elements), we can accumulate the partial results in FP32 and then save the final output as FP16 before saving into memory. Point-wise operations can be executed in either FP16 or FP32.&lt;/li&gt;
&lt;/ul&gt;

&lt;p style=&quot;width: 60%;&quot; class=&quot;center&quot;&gt;&lt;img src=&quot;/assets/images/post/gradient-histogram.png&quot; alt=&quot;Gradient histogram&quot; /&gt;&lt;/p&gt;
&lt;p class=&quot;image-caption&quot;&gt;&lt;em&gt;Fig. 17. The histogram of gradients in full precision. The left part up to \(2^{-24}\) will be zero-ed off once the model switches to FP16. (Image source: &lt;a href=&quot;https://arxiv.org/abs/1710.03740&quot;&gt;Narang &amp;amp; Micikevicius, et al. 2018&lt;/a&gt;)&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In their experiments, loss scaling is not needed for some networks (e.g. image classification, Faster R-CNN), but necessary for others (e.g. Multibox SSD, big LSTM language model).&lt;/p&gt;

&lt;h3 id=&quot;compression&quot;&gt;Compression&lt;/h3&gt;

&lt;p&gt;Intermediate results often consume a lot of memory, although they are only needed in one forward pass and one backward pass. There is a noticeable temporal gap between these two uses. Thus &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/04/fiddle-gist-isca18.pdf&quot;&gt;Jain et al. (2018)&lt;/a&gt; proposed a data encoding strategy to compress the intermediate results after the first use in the first pass and then decode it back for back-propagation later.&lt;/p&gt;

&lt;p&gt;Their system &lt;em&gt;Gist&lt;/em&gt; incorporates two encoding schemes:
&lt;em&gt;Layer-specific lossless encoding&lt;/em&gt;; focus on ReLU-Pool (“Binarize”) and ReLU-Conv (“Sparse storage and dense computation”) patterns.
&lt;em&gt;Aggressive lossy encoding&lt;/em&gt;; use delayed precision reduction (DPR). They observed that the first immediate use of feature maps should be kept at high precision but the second use can tolerate lower precision.&lt;/p&gt;

&lt;p&gt;The experiments showed that Gist can reduce the memory cost by 2x across 5 SOTA image classification DNNs, with an average of 1.8x with only 4% performance overhead.&lt;/p&gt;

&lt;h3 id=&quot;memory-efficient-optimizer&quot;&gt;Memory Efficient Optimizer&lt;/h3&gt;

&lt;p&gt;Optimizers are eager for memory consumption. Take the popular Adam optimizer as an example, it internally needs to maintain momentums and variances, both at the same scale as gradients and model parameters. All out of a sudden, we need to save 4x the memory of model weights.&lt;/p&gt;

&lt;p&gt;Several optimizers have been proposed to reduce the memory footprint. 
For example, instead of storing the full momentums and variations as in Adam, &lt;em&gt;Adafactor&lt;/em&gt; (&lt;a href=&quot;https://arxiv.org/abs/1804.04235&quot;&gt;Shazeer et al. 2018&lt;/a&gt;) only tracks the per-row and per-column sums of the moving averages and then estimates the second moments based on these sums. &lt;em&gt;SM3&lt;/em&gt; (&lt;a href=&quot;https://arxiv.org/abs/1901.11150&quot;&gt;Anil et al. 2019&lt;/a&gt;) describes a different adaptive optimization method, leading to largely reduced memory as well.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;ZeRO&lt;/em&gt; (&lt;em&gt;Zero Redundancy Optimizer&lt;/em&gt;; &lt;a href=&quot;https://arxiv.org/abs/1910.02054&quot;&gt;Rajbhandari et al. 2019&lt;/a&gt;) optimizes the memory used for training large models based on the observation about two major memory consumption of large model training:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The majority is occupied by &lt;em&gt;model states&lt;/em&gt;, including optimizer states (e.g. Adam momentums and variances), gradients and parameters. Mixed-precision training demands a lot of memory since the optimizer needs to keep a copy of FP32 parameters and other optimizer states, besides the FP16 version.&lt;/li&gt;
  &lt;li&gt;The remaining is consumed by activations, temporary buffers and unusable fragmented memory (named &lt;em&gt;residual states&lt;/em&gt; in the paper).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;ZeRO combines two approaches, &lt;em&gt;ZeRO-DP&lt;/em&gt; and &lt;em&gt;ZeRO-R&lt;/em&gt;. 
ZeRO-DP is an enhanced data parallelism to avoid simple redundancy over model states. It partitions optimizer state, gradients and parameters across multiple data parallel processes via a dynamic communication schedule to minimize the communication volume.
ZeRO-R optimizes the memory consumption of residual states, using partitioned activation recomputation, constant buffer size and on-the-fly memory defragmentation.&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;Cited as:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@article{weng2021large,
  title   = &quot;How to Train Really Large Models on Many GPUs?&quot;,
  author  = &quot;Weng, Lilian&quot;,
  journal = &quot;lilianweng.github.io/lil-log&quot;,
  year    = &quot;2021&quot;,
  url     = &quot;https://lilianweng.github.io/lil-log/2021/09/24/train-large-neural-networks.html&quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;

&lt;p&gt;[1] Li et al. &lt;a href=&quot;https://arxiv.org/abs/2006.15704&quot;&gt;“PyTorch Distributed: Experiences on Accelerating Data Parallel Training”&lt;/a&gt; VLDB 2020.&lt;/p&gt;

&lt;p&gt;[2] Cui et al. &lt;a href=&quot;https://www.pdl.cmu.edu/PDL-FTP/CloudComputing/GeePS-cui-eurosys16.pdf&quot;&gt;“GeePS: Scalable deep learning on distributed GPUs with a GPU-specialized parameter server”&lt;/a&gt; EuroSys 2016&lt;/p&gt;

&lt;p&gt;[3] Shoeybi et al. &lt;a href=&quot;https://arxiv.org/abs/1909.08053&quot;&gt;“Megatron-LM: Training Multi-Billion Parameter Language Models Using Model Parallelism.”&lt;/a&gt; arXiv preprint arXiv:1909.08053 (2019).&lt;/p&gt;

&lt;p&gt;[4] Narayanan et al. &lt;a href=&quot;https://arxiv.org/abs/2104.04473&quot;&gt;“Efficient Large-Scale Language Model Training on GPU Clusters Using Megatron-LM.”&lt;/a&gt; arXiv preprint arXiv:2104.04473 (2021).&lt;/p&gt;

&lt;p&gt;[5] Huang et al. &lt;a href=&quot;https://arxiv.org/abs/1811.06965&quot;&gt;“GPipe: Efficient Training of Giant Neural Networks using Pipeline Parallelism.”&lt;/a&gt; arXiv preprint arXiv:1811.06965 (2018).&lt;/p&gt;

&lt;p&gt;[6] Narayanan et al. &lt;a href=&quot;https://cs.stanford.edu/~matei/papers/2019/sosp_pipedream.pdf&quot;&gt;“PipeDream: Generalized Pipeline Parallelism for DNN Training.”&lt;/a&gt; SOSP 2019.&lt;/p&gt;

&lt;p&gt;[7] Narayanan et al.  &lt;a href=&quot;https://arxiv.org/abs/2006.09503&quot;&gt;“Memory-Efficient Pipeline-Parallel DNN Training.”&lt;/a&gt; ICML 2021.&lt;/p&gt;

&lt;p&gt;[8] Shazeer et al. &lt;a href=&quot;https://arxiv.org/abs/1701.06538&quot;&gt;“The Sparsely-Gated Mixture-of-Experts Layer Noam.”&lt;/a&gt; arXiv preprint arXiv:1701.06538 (2017).&lt;/p&gt;

&lt;p&gt;[9] Lepikhin et al. &lt;a href=&quot;https://arxiv.org/abs/2006.16668&quot;&gt;“GShard: Scaling Giant Models with Conditional Computation and Automatic Sharding.”&lt;/a&gt; arXiv preprint arXiv:2006.16668 (2020).&lt;/p&gt;

&lt;p&gt;[10] Fedus et al. &lt;a href=&quot;https://arxiv.org/abs/2101.03961&quot;&gt;“Switch Transformers: Scaling to Trillion Parameter Models with Simple and Efficient Sparsity.”&lt;/a&gt; arXiv preprint arXiv:2101.03961 (2021).&lt;/p&gt;

&lt;p&gt;[11] Narang &amp;amp; Micikevicius, et al.  &lt;a href=&quot;https://arxiv.org/abs/1710.03740&quot;&gt;“Mixed precision training.”&lt;/a&gt; ICLR 2018.&lt;/p&gt;

&lt;p&gt;[12] Chen et al. 2016 &lt;a href=&quot;https://arxiv.org/abs/1604.06174&quot;&gt;“Training Deep Nets with Sublinear Memory Cost.”&lt;/a&gt; arXiv preprint arXiv:1604.06174 (2016).&lt;/p&gt;

&lt;p&gt;[13] Jain et al. &lt;a href=&quot;https://www.microsoft.com/en-us/research/uploads/prod/2018/04/fiddle-gist-isca18.pdf&quot;&gt;“Gist: Efficient data encoding for deep neural network training.”&lt;/a&gt; ISCA 2018.&lt;/p&gt;

&lt;p&gt;[14] Shazeer &amp;amp; Stern. &lt;a href=&quot;https://arxiv.org/abs/1804.04235&quot;&gt;“Adafactor: Adaptive learning rates with sublinear memory cost.”&lt;/a&gt; arXiv preprint arXiv:1804.04235 (2018).&lt;/p&gt;

&lt;p&gt;[15] Anil et al. &lt;a href=&quot;https://arxiv.org/abs/1901.11150&quot;&gt;“Memory-Efficient Adaptive Optimization.”&lt;/a&gt; arXiv preprint arXiv:1901.11150 (2019).&lt;/p&gt;

&lt;p&gt;[16] Rajbhandari et al. &lt;a href=&quot;https://arxiv.org/abs/1910.02054&quot;&gt;“ZeRO: Memory Optimization Towards Training A Trillion Parameter Models Samyam.”&lt;/a&gt; arXiv preprint arXiv:1910.02054 (2019).&lt;/p&gt;</content><author><name>Lilian Weng</name></author><category term="architecture" /><category term="transformer" /><summary type="html">[PLACE-HOLDER POST, COPYRIGHT LILIAN WENG] How to train large and deep neural networks is challenging, as it demands a large amount of GPU memory and a long horizon of training time. This post reviews several popular training parallelism paradigms, as well as a variety of model architecture and memory saving designs to make it possible to train very large neural networks across a large number of GPUs.</summary></entry></feed>